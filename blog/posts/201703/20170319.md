<!--
author: checkking
date: 2017-03-19
title: Google Protobuffer "Base 128 Varints"编码
tags: protobuffer
category: protobuffer
status: publish
summary: Google Protobuffer编码笔记
-->
### Base 128 Varints
官方描述：Each byte in a varint, except the last byte, has the most significant bit (msb) set – this indicates that there are further bytes to come. The lower 7 bits of each byte are used to store the two's complement representation of the number in groups of 7 bits, **least significant group first**.
也就是：

1. 除了最后一个字节，varint中的每个字节的最高位设为1，表示后面还有字节出现
2. 每个字节的低7位看成是一个组（group），这个组和他相邻的下一个7位组共同存储某个整形的“组合表示”，最低有效组在前面。

例子：
1. 一个字节。下面只有一个字节，所以最高位是0，表示十进制1
```bash
0000 0001
```

2. 两个字节
```bash
1010 1100 0000 0010
```
由于第一个字节后面还有一个字节，所以第一个字节的最高位设置为1，表示后面还有后继字节，第二个字节的最高位为0。去掉每个字节的最高位，我们对两个字节进行分组。第一个7位组：0101100，第二个7位组：0000010，组合起来就是：0101100 0000010。
由于protobuffer采用小端字节序([关于字节序](https://en.wikipedia.org/wiki/Endianness))，也就是数据的低位保存在内存的低地址中，调整为`0101100 0000010`, 十进制为`2^8 + 2^5 + 2^3 + 2^2 = 300`

300 的二进制表示为 100101100，通过 Varint 编码后的二进制表示为 10101100 00000010，详细过程如下：
![编码](../../img/201703/20170320.png)

### ZigZag
上节介绍了 Varints，我们知道 Varint 在处理小数值的数字很有效，而在处理值较大的数字则占用了多一个子节。对于负数来说，二进制最高有效位为 1，如果用 varint 来编码，无疑要占用比较多的子节。因此我们可以搭配 zigzag 来编码。

ZigZag 编码将有符整型转化成无符的整型，其原理是将最高位的符号位放到最低位（－1 除外），这样大大减少了字节占用。

举个例子，-2 的二进制表示为 1111 1110，用zigzag编码，－2 的绝对值为 2，二进制为 0000 0010，将符号位放到最低位，则变成 0000 0011。

公式如下：
- 32 位整型：(n << 1) ^ (n >> 31)
- 64 位整型：(n << 1) ^ (n >> 63)

> Note that the second shift – the (n >> 31) part – is an arithmetic shift. So, in other words, the result of the shift is either a number that is all zero bits (if n is positive) or all one bits (if n is negative).

注意这里的位移操作符。如果在位移运算符左边的变量是有符号数，编译产生的汇编指令是算术位移指令，如果该变量是无符号数，编译产生的汇编指令则是逻辑位移指令。对于左移，它们都一样，整个二进制右移，低位补 0；右移则有所区分，算数右移左边补最高符号位，逻辑位移左边补 0。

举个例子，-2 经过 ZigZag 编码后为 3，过程如下：
![ZigZag编码](../../img/201703/illustration-3.png)
